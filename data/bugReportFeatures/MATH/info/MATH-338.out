{
	"desc":"\n\nIn a space application using DOP853 i detected what seems to be a bad parameter in the call to the method  initializeStep of class AdaptiveStepsizeIntegrator.\nHere, DormandPrince853Integrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate(...)\nThe problem comes from the array \"scale\" that is used as a parameter in the call off initializeStep(..)\nFollowing the theory described by Hairer in his book \"Solving Ordinary Differential Equations 1 : Nonstiff Problems\", the scaling should be :\nsci = Atol i + |y0i| * Rtoli\nWhereas EmbeddedRungeKuttaIntegrator uses :  sci = Atoli\nNote that the Gragg-Bulirsch-Stoer integrator uses the good implementation \"sci = Atol i + |y0i| * Rtoli  \" when he performs the call to the same method initializeStep(..)\nIn the method initializeStep, the error leads to a wrong step size h used to perform an  Euler step. Most of the time it is unvisible for the user.\nBut in my space application the Euler step with this wrong step size h (much bigger than it should be)  makes an exception occur (my satellite hits the ground...)\nTo fix the bug, one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator\nFor exemple :\n final double[] scale= new double[y0.length];;\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) \n{\n                final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) \n{\n                final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                           stepStart, y, yDotK[0], yTmp, yDotK[1]);\nSorry for the length of this message, looking forward to hearing from you soon\nVincent Morand\n\n", 
	"remain":"\n\nIn a space application using DOP853 i detected what seems to be a bad parameter in the call to the method  initializeStep of class AdaptiveStepsizeIntegrator.\nHere, DormandPrince853Integrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate(...)\nThe problem comes from the array \"scale\" that is used as a parameter in the call off initializeStep(..)\nFollowing the theory described by Hairer in his book \"Solving Ordinary Differential Equations 1 : Nonstiff Problems\", the scaling should be :\nsci = Atol i + |y0i| * Rtoli\nWhereas EmbeddedRungeKuttaIntegrator uses :  sci = Atoli\nNote that the Gragg-Bulirsch-Stoer integrator uses the good implementation \"sci = Atol i + |y0i| * Rtoli  \" when he performs the call to the same method initializeStep(..)\nIn the method initializeStep, the error leads to a wrong step size h used to perform an  Euler step. Most of the time it is unvisible for the user.\nBut in my space application the Euler step with this wrong step size h (much bigger than it should be)  makes an exception occur (my satellite hits the ground...)\nTo fix the bug, one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator\nFor exemple :\n              for (int i = 0; i < scale.length; ++i) \n                final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n            } else {\n{\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                           stepStart, y, yDotK[0], yTmp, yDotK[1]);\nSorry for the length of this message, looking forward to hearing from you soon\nVincent Morand\n", 
	"source":"final double[] scale= new double[y0.length];;\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) \n{\n                final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n              }\n            }\n            } else {\n              for (int i = 0; i < scale.length; ++i) \n{\n                final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n              }\n            }", 
	"talks":"", 
	"traces":[], 
	"enums":[]}